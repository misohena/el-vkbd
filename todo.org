#+TITLE: Emacs Virtual Keyboard TODO List
#+DATE: [2025-11-14 Fri]
#+AUTHOR: AKIYAMA Kouhei

* Inbox
** TODO 既存のIMEと併用することを前提としたコンパクトレイアウトを追加する
BS、RET、SPCは要らない！
といってもアルファベットを入れるならあまり小さくならないなぁ。
まぁ、ATOKでもモードを変えればアルファベットを入力できるわけだし、どうやっても入力できない文字に限定したレイアウトがあれば良いかも。

*修飾キーとの兼ね合いを考える必要がある。* 現状では、C-を押した後IMEのアルファベットを押してもそれにC-は適応されない。これを実現するにはC-が押されて解放された後にさらに次のキー入力までread-eventで待つ必要がある(modifier-bar-modeはこれをやっている)。

** TODO フレームの位置を記憶する
(locate-user-emacs-file "vkbd") "~/.emacs.d/vkbd"

** TODO 余計なフレームサイズ変更を無くす
** TODO キーの幅に任意の数のcolumn-separatorの幅を追加できるようにする
配列を整えるのに必要。

** TODO key-idは要らない。
keyboardが全てのキーを保持していれば、オブジェクトのeqで判別できる。
とは言え、それが本当に良いのだろうか。
Hacker's KeyboardのようにFnキーを押したらレイアウト毎全部書き換わるような場合、どのみちキーオブジェクトも全部更新しなければならない。
それなら全更新関数でキーオブジェクト毎作り直した方が早いのではないか。
キーオブジェクトをキーボードオブジェクトが一貫して管理する必要はあるのだろうか。
キーオブジェクトはスタイルの物なのか、それともキーボードオブジェクトの物なのか。

** TODO Shift+シフトありキーを押したときにshiftで修飾しない
例えば一つのキーに(?a del)を割り当てたときに、Shiftとこのキーを押すとS-<delete>を押したことになってしまう。S-<delete>の入力は諦めて<delete>だけが入力されるべき。普通の記号でも同じ問題は起きないのだろうか。

** TODO 長押しでキーリピートする
** TODO 使用できないシチュエーションについて調べる
[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Reading-Input.html][Reading Input (GNU Emacs Lisp Reference Manual)]]
- read-key-sequenceは機能しているっぽい。
- read-eventには効かない。
- read-char、read-char-exclusiveは正しく機能しない。
- read-key、read-char-choiceは機能する。
- read-multiple-choiceは正しく機能しない。
- read-quoted-charは正しく機能しない。
他にも:
- transient.elは正しく機能しない。一時マップという手法(set-transient-mapと同じようにoverriding-terminal-local-map等を一時的に書き替えるのであれば、今のバッファで発生するイベントにしか効果が無いのは当たり前)
- set-transient-mapも当然効かない。

** TODO フレームの入力フォーカスを制御する
- できるだけキーにフォーカスして、フォーカスが外れたら閉じるモード
- できるだけ親フレームにフォーカスするモード
- touchscreen-updateやendでフォーカスが戻ってしまっている？

** TODO SVGキーボードスタイルを追加する
** TODO Emacsのオンスクリーンキーボードとして使えるようにする
** TODO vkbd-tool-bar-modeを作る?
** TODO 任意のバッファ内に直接キーボードを生成できるようにする
バッファローカルキーボードを作りたい。SVG画像じゃないと実用的じゃないと思う。これをやるならキーボードの状態はバッファに持たせない方が良い。一つのバッファに複数のキーボードを配置する可能性があるので。

** TODO ポイント(カーソル)の位置を自動的に避けてくれるモード
** TODO 自動的に小さくなったり大きくなってくれたりするモード
** TODO フレームサイズをドラッグで変えられるようにする
** TODO フレームのドラッグ移動後にフォーカスを外すべき？
** TODO (子フレームではなく)独立フレームで使えるようにする
** TODO (フレームではなく)ウィンドウで表示できるようにする
正直分割ウィンドウの下半分もしくは上半分に表示してくれた方が使いやすいのでは？
また、フォーカススイッチによって生じる問題も低減できるはず。

** TODO フレームを閉じたときにバッファも消えるようにする
たまたまフォーカスが当たっているときにC-x 5 0で閉じるとバッファが残る。

** TODO タッチ操作でレイアウトを変更できるようにしたい

** TODO メニューボタンを配置する？
メニュー項目:
- レイアウト切り替え
** TODO サイズをoptionsで変更できるようにしたい
今はvkbd-text-keyboardを変更しなければならない。

** TODO フレームパラメータalphaを指定してみる(半透明にする)
狭い画面で使うので後ろが見えた方が良い。
うーん、Windowsでは効くけどAndroidでは効かないみたい。
それならいいや。そのうち対応したら。

** TODO タイトルバーにヘッダーラインを使う
[[https://ayatakesi.github.io/lispref/29.1/html/Child-Frames.html][Child Frames (GNU Emacs Lisp Reference Manual)]]にも書いてあるとおりheader-lineをタイトルバー代わりに使える。

- フレームパラメータのdrag-with-header-lineをt
- バッファーローカル変数のheader-line-formatに閉じるボタンとキャプション
- 閉じるボタンのイベントは[header-line mouse-1]等に登録する

これでマウスで移動することも閉じることもできる。

しかしAndroidでタッチによる移動は出来なかった。
実装されていない？　それじゃ意味が無いので元に戻した。

** TODO キーボードバッファでの入力イベントを抑制する
キーボードバッファにフォーカスを持たせて何か入力したときにエラーが発生して鬱陶しいので。

** TODO ハーボードバッファでスクロール出来てしまうのを抑制する
* Finished
** DONE 子フレームにキーボードを表示する
CLOSED: [2025-11-15 Sat 00:31]

** DONE キーマップ変換の仕組みを理解する
CLOSED: [2025-11-16 Sun 12:38]

*** マニュアルや既存ソースコードの例
[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Translation-Keymaps.html][Translation Keymaps (GNU Emacs Lisp Reference Manual)]]に説明がある。そこにはlocal-function-key-mapを使用してC-c hで後続のイベントにH-を付加する例がある。

[[elisp-function:modifier-bar-mode]]は[[elisp-variable:input-decode-map]]を使用している。[[elisp-function:tool-bar-event-apply-control-modifier]]関数等を通じて[[elisp-function:modifier-bar-button]]関数が呼ばれる。

[[elisp-library:touch-screen][touch-screen.el]]はfunction-key-mapを使用している。[[elisp-function:touch-screen-translate-touch]]関数が呼ばれる。

とりわけ[[elisp-function:touch-screen-translate-touch]]関数は大いに参考になる。呼ばれた時点でのイベントを[[elisp-variable:current-key-remap-sequence]]変数から取得している。

*** 単純な変換関数を作って挙動を探る
ひとまず何も変換しない変換関数を作ってログを出力させてみる。

#+begin_src elisp
(defun my-test-translate-event (prompt)
  (message "Translate curr=%s prompt=%s" current-key-remap-sequence prompt)
  current-key-remap-sequence
  ;; nil
  ;; []
  ;; [?a]
  ;; [?a ?b]
  )

(define-key input-decode-map [down-mouse-1] #'my-test-translate-event)
;; (define-key input-decode-map [down-mouse-1] nil t)
#+end_src

上のコードを評価した後、このバッファ内をマウスで押してみると次のようなメッセージが得られた。

: Translate curr=[(down-mouse-1 (#<window 947 on todo.org<el-vkbd>> 1186 (508 . 256) 87241859 nil 1186 (63 . 12) nil (508 . 16) (8 . 20)))] prompt=nil

それと同時にポイント(テキストカーソル)は押した位置に移動する。

my-test-translate-eventの戻り値を変えてみる。試しにnilを返すように変更してもそれは変わらない。しかし ~[]~ を返すようにしたら押した時点では移動しなかった(離したときに移動する)。

| 戻り値                     | 挙動                      |
|----------------------------+---------------------------|
| current-key-remap-sequence | 押し下げ時移動            |
| nil                        | 押し下げ時移動            |
| []                         | 押し下げ時移動しない      |
| [?a]                       | aが挿入                   |
| [?a ?b]                    | bが挿入(複数は返せない！) |

入力関数はどのような結果を返すだろうか。my-test-translate-eventが ~[?a]~ を返すようにした上で試してみる。

#+begin_src elisp
(read-event "Prompt: ") ;; => (down-mouse-1 (#<window 947 on todo.org<el-vkbd>> 2044 (249 . 473) 88984375 nil 2044 (31 . 23) nil (57 . 13) (8 . 20)))
(read-char "Prompt: ") ;; ERROR: (error "Non-character input-event")
(read-char-choice "Prompt: " '(?a ?b)) ;; => 97
(read-key "Prompt: ") ;; 押し下げ時に返ってこず、解放時にmouse-1
(read-key-sequence "Prompt: ") ;; => "a"
#+end_src

疑問点・アイデア:
- 複数の入力を返せないなら、イベントを新たに追加してしまってはどうか。
- read-eventにも効かせたいならinput-method-functionを使ってはどうか。
- バッファローカルなlocal-function-key-mapで十分かもしれない。
- フレーム跨ぎ(変換前と後のフレームが異なる)問題をどうするか。

*** イベント追加技
わざわざ変換するのではなく、直接[[elisp-variable:unread-command-events]]に追加してしまえば良い。

#+begin_src elisp
(defun my-test-translate-event (prompt)
  (message "Translate curr=%s prompt=%s" current-key-remap-sequence prompt)
  (setq unread-command-events (list ?a ?b))
  [])
#+end_src

こうすると実際に押し下げ時点でaとbが両方バッファに挿入される。

*** input-method-function
[[elisp-function:read-event]]の説明を読むとinput-methodについて書かれている。

[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Reading-Input.html][Reading Input (GNU Emacs Lisp Reference Manual)]]を見るとread-eventが値を返す前に[[elisp-variable:input-method-function]]が処理を行うことが分かる。

[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Invoking-the-Input-Method.html][Invoking the Input Method (GNU Emacs Lisp Reference Manual)]]

#+begin_quote
22.8.4 入力メソッドの呼び出し

イベント読み取り関数は、現在の入力メソッドがある場合はそれを呼び出します (「入力メソッド」を参照)。input-method-function の値が nil 以外の場合、関数である必要があります。read-event は、修飾ビットのない印刷文字 (SPC を含む) を読み取ると、その関数を呼び出して、その文字を引数として渡します。
#+end_quote

#+begin_src elisp
(defun my-test-input-method-func (char)
  (message "char=%s" char)
  (list char))
(setq-local input-method-function #'my-test-input-method-func)
;; (setq-local input-method-function 'list)
#+end_src

残念ながらマウスイベント発生時は呼ばれない。 *修飾ビットのない印刷文字 (SPC を含む) を読み取ると* と書かれている通り。残念。

*** local-function-key-mapを使う?
local-function-key-mapはマイナーモード、ローカルマップ、グローバルマップ等で使われなかったイベントに対して効く物で、バッファローカルという意味ではない。なので使う意味が無い。

*** フレーム跨ぎ問題
子フレームで仮想キーボードを表示する場合、マウスイベントが発生するフレームと入力反映させるフレームが異なるという問題がある。

次のコードはマウスイベント発生位置にあるテキストプロパティ my-test-input の値をunread-command-eventsに追加する。

#+begin_src elisp
(defun my-test-translate-event (prompt)
  (message "Translate curr=%s prompt=%s" current-key-remap-sequence prompt)
  (when (= (length current-key-remap-sequence) 1)
    (let ((event (aref current-key-remap-sequence 0)))
      (when (mouse-event-p event)
        (let* ((posn (event-start event))
               (window (posn-window posn))
               (point (posn-point posn)))
          (with-current-buffer (window-buffer window)
            (when (< point (point-max))
              (let ((input (get-text-property point 'my-test-input)))
                (when input
                  (setq unread-command-events
                        (append unread-command-events
                                input
                                nil))
                  [])))))))))
(define-key input-decode-map [down-mouse-1] #'my-test-translate-event)
;; (define-key input-decode-map [down-mouse-1] nil t)
#+end_src

つまりそのようなテキストプロパティ付きのテキストをバッファに挿入すると、入力を行うボタンとして機能する。

#+begin_src elisp
(defun my-test-create-input-button ()
  (insert (propertize "[Input a b]" 'my-test-input '(?a ?b))))
;; (my-test-create-input-button) [Input a b]
#+end_src

my-test-create-input-buttonを評価するとabを入力するボタンがバッファに挿入される。

現在のバッファにあるボタンを押した場合はバッファの遷移が無いので問題なくabが入力される。

しかし現在のバッファ以外にあるボタンを押した場合はどうなるだろうか。

別のウィンドウにあるボタンを押した場合、まだウィンドウが遷移する前なので元のウィンドウのバッファにabが入力される。

別のフレームにあるボタンを押した場合、フレームが遷移してからマウスイベントが発生するため別のフレームで現在選択中のウィンドウにあるバッファ(ボタンがあるバッファではない)にabが入力される。

別フレームをマウスを押してもフレームの遷移が発生しないようにする方法はおそらくない。

一番手っ取り早いのはselect-frame(もしくはselect-frame-set-input-focus)で戻してしまうこと。

#+begin_src elisp
(defvar my-test-main-frame (selected-frame)) ;; 仮の戻し先

(defun my-test-translate-event (prompt)
  (message "Translate curr=%s prompt=%s" current-key-remap-sequence prompt)
  (when (= (length current-key-remap-sequence) 1)
    (let ((event (aref current-key-remap-sequence 0)))
      (when (mouse-event-p event)
        (let* ((posn (event-start event))
               (window (posn-window posn))
               (point (posn-point posn)))
          (with-current-buffer (window-buffer window)
            (when (< point (point-max))
              (let ((input (get-text-property point 'my-test-input)))
                (when input
                  (select-frame my-test-main-frame)
                  (setq unread-command-events
                        (append unread-command-events
                                input
                                nil))
                  [])))))))))
#+end_src

子フレームであれば親フレームに戻してしまえば良い。

*** 結論
- フィルタ関数は自分の処理すべきイベントが来たときに、unread-command-eventsにキーを追加して[]を返すべし。そうでなければnilを返せば良い。
- 子フレームを選択させたくなければselect-frameやselect-frame-set-input-focusを使って無理矢理親フレームを選択してしまえば良い。
** DONE Emacsの(マウス・タッチ)イベントからキーを入力する仕組みを作る
CLOSED: [2025-11-16 Sun 12:43]
** DONE 子フレームをドラッグで移動できるようにする
CLOSED: [2025-11-16 Sun 17:53]
** DONE 子フレームを閉じるボタンを追加する
CLOSED: [2025-11-16 Sun 17:53]
** DONE Androidでのドラッグ移動がカクつくのを直す
CLOSED: [2025-11-16 Sun 23:51]
タッチイベント時にタッチでフレームを移動すると、フレームが振動して発散しウィンドウ範囲外に飛び出して見えなくなってしまうことがある。
フレーム移動直後におかしな座標を持つtouchscreen-updateイベントが発生することが原因。
touchscreen-updateイベントは指を動かさなくてもフレームを移動しただけで発生する。
おそらくフレーム位置を変更した直後に変更前のタッチ座標を元にイベントが送られてきているのではないか。
いずれにせよEmacs Lispからではそれが正しい座標なのか不正な座標なのか判断できない。
フレーム移動直後のイベントは信用できないので、移動した時刻を記録しておいて、一定時間(vkbd-frame-move-debounce-time変数)経った後でなければ処理しないようにした。

** DONE シフトキーで入力する文字を表示できるようにする
CLOSED: [2025-11-16 Sun 23:50]

** DONE レイアウトとスタイルを分離する
CLOSED: [2025-11-16 Sun 23:49]

** DONE キーを半分ずらせるようにする
CLOSED: [2025-11-16 Sun 23:50]

** DONE JPキーボードレイアウトを追加する
CLOSED: [2025-11-16 Sun 23:49]

** DONE USキーボードレイアウトを追加する
CLOSED: [2025-11-16 Sun 23:49]

** DONE シフトキー併用で記号を入力できるようにする
CLOSED: [2025-11-17 Mon 11:35]
キーを表すのにkey-typeではなくkey-dataという構造を使うようにする。
key-dataは一つのキーを表し、key-typeは実際に入力されるものを表す。

** DONE よりコンパクトなレイアウトを追加する
CLOSED: [2025-11-17 Mon 11:37]
- vkbd-layout-10x7 : 記号の1文字入力にこだわらないレイアウト
- vkbd-layout-10x6 : ほとんどの記号にShiftが必要、InsとDelを削除

** DONE グローバルキーボードのopen・closeコマンドを作る
CLOSED: [2025-11-17 Mon 12:25]
M-x vkbd-open-global-keyboardでキーボードを開き、M-x vkbd-close-global-keyboardで閉じるというだけのものがあれば便利。

** DONE ツールバーにグローバルキーボードトグルボタンを追加する
CLOSED: [2025-11-17 Mon 16:32]

** DONE row-separatorをもう少し狭くする
CLOSED: [2025-11-17 Mon 23:37]
狭くならない原因はline-spacingだった。frame-parameterのline-spacingパラメータは無視されるみたい。私はデフォルト値(グローバル値)を4にしているから、それが使われて行間が大きくなっていた。
vkbd-keyboard-buffer-line-spacing変数を追加。

** DONE シフト時キーがある場合のraise値をカスタマイズできるようにする
CLOSED: [2025-11-18 Tue 11:33]
line-spacingを小さくしたら下に寄りがちになってしまった。
シフトキーが無いときも調整できた方が良いかも。

vkbd-text-key-raise変数を追加。

ついでにvkbd-text-keyboard-key-data-string関数を全体的に修正する。

** DONE 11x7レイアウトを追加する
CLOSED: [2025-11-18 Tue 13:43]
Pixel7での私のフォント設定だと、あと1列分くらいは入る。
もう少し記号をシフト無しで入力したい。
特に ( と ) はLispのコードを書くなら頻出するので、必ずシフト無しにしたい。
また、diredで上のディレクトリに移動するのに ^ を使っているので、これもシフト無しに為たい。
() [] <> は一貫して同じ列に配置。
+-*=といった算術に使う物も全てシフトキー無しで近くに配置。
_もプログラミング言語によってはよく使うのでシフト無し。
!#$%はUSでもJPでも数字キーの同じ場所にある。これらはそのままの並びで上の方に並べる。
全体的に、右上のShiftの近くに寄せる。

** DONE 2ストロークキーが入力できない問題を修正する
CLOSED: [2025-11-18 Tue 19:10]

例えば C-c C- と複数ストロークのキーを押したときに、<mouse-1> undefinedと表示される。

二つ目のC-を押したときになぜか down-mouse-1 に対する変換関数は呼ばれないのにその後の mouse-1 は呼ばれる。そして C-c mouse-1 を実行しようとして、そんな組み合わせはキーマップにないのでエラーになる。

modifier-bar-modeはなぜかこれが問題なく動作する。modifier-barでC-を押した後キーでcを押し、その後にmodifier-barでC-を押すと C-c tool-bar control- と表示されるが、その時にちゃんと変換関数は呼ばれており、続いてcなどと押せば[tool-bar control-]+?cが[3]になってC-c C-cを押したことになる。

(read-key-sequence "Prompt: ") のレベルでそのような挙動になる。

#+begin_src elisp
(defun my-mouse-translator (prompt)
  (message "Enter translator %s" current-key-remap-sequence)
  [?q])

;; (define-key input-decode-map (kbd "<down-mouse-1>") nil t)
(define-key input-decode-map (kbd "<down-mouse-1>") #'my-mouse-translator)
#+end_src

上を評価してからマウスボタンを押すと押し下げた瞬間にメッセージが表示される。

C-cをキーボードから直接した後、マウスボタンを押し下げると「C-c (C-h for help)」または「C-c down-mouse-1-(C-h for help)」と表示される(C-cを押してからメッセージが出てからマウスを押すと後者になるようだ)。そしてマウスボタンを解放すると C-c <mouse-1> is undefinedと表示される。

#+begin_src elisp
;; (define-key input-decode-map (kbd "<down-mouse-1>") nil t)
(define-key input-decode-map (kbd "<down-mouse-1>") #'my-mouse-translator)
;; (define-key input-decode-map (kbd "C-c <down-mouse-1>") nil t)
(define-key input-decode-map (kbd "C-c <down-mouse-1>") #'my-mouse-translator)
#+end_src

としても無駄。キーでC-cを押してからマウスを押し下げてもC-c <down-mouse-1>の変換関数は呼ばれない。これはC-x、ESCでも同じだった。

#+begin_src elisp
;; (define-key input-decode-map (kbd "<mouse-1>") nil t)
(define-key input-decode-map (kbd "<mouse-1>") #'my-mouse-translator)
#+end_src

しかしこれは呼ばれる。C-c の後に押し下げても何も呼ばれないのは同じ。しかしその後解放するとmouse-1に対する変換関数は呼ばれる。ちなみにこれはmouse-1をdrag-mouse-1にしても同じ。解放イベントだけ変換される。down-mouse-1がどこへ消えたのか分からない。

まとめると、C-cやC-x、ESCのようなプレフィックスの直後ではdown-mouse-1は変換されず、その後のmouse-1やdrag-mouse-1は変換される。

ただしmouse-2はdown-mouse-2だけ登録してもプレフィックス無しでも変換関数は呼ばれない。down-mouse-3は大丈夫。

もう何が何だか分からない。

今できること:
- down-mouse-1とmouse-1の両方を監視する。
- down-mouse-1が来たらmouse-1かdrag-mouse-1を待ってから終了。
- いきなりmouse-1が来たらすぐに終了。

↑はダメだった。down-mouse-1の変換中にread-eventを呼ぶとdown-mouse-1の変換が再度呼ばれて無限ループに陥った。

結局最後は unread-command-events を使うのを止めた。つまり変換結果を完璧に処理すれば良い。
- キーボードバッファ内
  - キーがある場所
    - イベントに変換できた
      [ イベント ... ]
    - イベントに変換できなかった(修飾キー等)
      [ ]  (握りつぶす)
  - キーが無い場所
    nil (閉じるボタンを押したりドラッグによるフレーム移動が出来るように)
- キーボードバッファ外
  nil (他での利用を邪魔しない)

** DONE 10x7レイアウトを修正する
CLOSED: [2025-11-18 Tue 20:48]
(と)をシフト無しで押したい！
InsとEndは諦める。HomeとEndは左に移動して残す。
できるだけ数字とアルファベット部分に記号を混ぜない。
数字の所にあった記号を最上段のシフトに移動する。並び順はUSに近づける。
ただし`'"の並びは特殊なのでそこは仕方ない。
上矢印の左右に@と?を移動する。
^がシフトになってしまうのは諦める。

** DONE SPCは何も表示しない方が良いかもしれない
CLOSED: [2025-11-18 Tue 22:04]
やっぱり真っ白なことを判別して押しているみたいなので、文字があるとすぐに分からない。

** DONE アルファベット部分に記号をシフトで入れるのを止める
CLOSED: [2025-11-19 Wed 18:20]
当たり前だけどそれだと大文字が打てなくなる。なんてこった。全く気が付いていなかった！
10x6レイアウトは削除する。維持不可能なので。

** DONE キー押し下げ中にキーの色を変更する
CLOSED: [2025-11-19 Wed 19:18]

** DONE 修飾キー押し下げ状態時にキーの色を変更する
CLOSED: [2025-11-20 Thu 11:22]
普通に押し下げの色にする。これはロックとは違う。

** DONE シフトキーの状態で大文字小文字の表示を切り替える
CLOSED: [2025-11-20 Thu 11:22]
更新メカニズムを整備する。

** DONE key-dataを何か他の用語に変える。
CLOSED: [2025-11-20 Thu 13:52]
key-type、key-data、key-objectと似たようなのが複数あって分かりづらい。
- key-type :: Emacsのキーシーケンス(イベントリスト)に名前を付けた物。
- key-data :: キーボードの中の一つのキーがどんなものなのか、静的な性質を記述する。シフトキーの有無によって複数のkey-typeが指定できる。任意の指定を追加できるプロパティリストも持てる(現状では:wでキーの幅が指定出来る)。
- key-object :: キーの動的な側面を含めて一つのオブジェクトとして操作できるようにする。

key-descriptorが一番しっくりくる。次いでkey-spec。key-attributeなんてのも。
vkbd-key-descriptor-*という関数名は長すぎる。key-descくらいでも悪くない。
いや、でもdescriptorという用語もそれほど分かりやすいものでは無いし、specの方が静的なイメージは上かも。予め指定されたキーの性質、という。ここは素直にspecにしよう。

** DONE 2回修飾キーを押したときに修飾キーをロックし、3回目で全て解除する
CLOSED: [2025-11-20 Thu 18:07]

** CANCELLED Caps Lockを追加する
CLOSED: [2025-11-20 Thu 18:07]
2回押しでロックできるようになったので不要。

** DONE フレームの移動範囲を限定する
CLOSED: [2025-11-21 Fri 11:39]
タイトルバーが半分……いや、1/3残っていれば良い。

vkbd-keyboard-frame-keep-visible-margins変数を追加した。
